DinosaurOccurrences[, 1]
is.numeric(DinosaurOccurrences[, 1])
DinosaurOccurrences <- read.table(file = "https://datadryad.org/bitstream/handle/10255/dryad.131030/dinosaur_occurrences.txt?sequence=1")
colnames(DinosaurOccurrences)
is.numeric(DinosaurOccurrences[, 1])
DinosaurOccurrences <- read.table(file = "https://datadryad.org/bitstream/handle/10255/dryad.131030/dinosaur_occurrences.txt?sequence=1", header = TRUE)
is.numeric(DinosaurOccurrences[, 1])
DinosaurOccurrences <- read.table(file = "https://datadryad.org/bitstream/handle/10255/dryad.131030/dinosaur_occurrences.txt?sequence=1", header = TRUE, row.names = 1)
rownames(DinosaurOccurrences)is.numeric(DinosaurOccurrences[, 1])
DinosaurOccurrences["Trannosaurus_rex", ]
DinosaurOccurrences["Tyrannosaurus_rex", ]
apply(DinosaurOccurrences, 1, sum)
hist(apply(DinosaurOccurrences, 1, sum))
hist(apply(DinosaurOccurrences, 1, sum), breaks = 0:100)
max(apply(DinosaurOccurrences, 1, sum))
hist(apply(DinosaurOccurrences, 1, sum), breaks = 0:70)
unname(apply(DinosaurOccurrences, 1, sum))
?file.copy
setwd("~")
list.files()
grep("trees_tnt", list.files())
list.files()[grep("trees_tnt", list.files())]
TreeFiles <- list.files()[grep("trees_tnt", list.files())]
LogFiles <- list.files()[grep("tnt_log", list.files())]
TreeFiles
gsub("[:A-Z:]", "", TreeFiles)
gsub("[:a-z:]", "", TreeFiles)
gsub("[:a-z:]|_", "", TreeFiles)
gsub("[:a-z:]|_|\.", "", TreeFiles)
gsub("[:a-z:]|_|\\.", "", TreeFiles)
as.numeric(gsub("[:a-z:]|_|\\.", "", TreeFiles))
order(as.numeric(gsub("[:a-z:]|_|\\.", "", TreeFiles)))
TreeFiles[order(as.numeric(gsub("[:a-z:]|_|\\.", "", TreeFiles)))]
TreeFiles <- TreeFiles[order(as.numeric(gsub("[:a-z:]|_|\\.", "", TreeFiles)))]
LogFiles[order(as.numeric(gsub("[:a-z:]|_|\\.", "", LogFiles)))]
LogFiles <- LogFiles[order(as.numeric(gsub("[:a-z:]|_|\\.", "", LogFiles)))]
999-875
0:123
for(i in 0:123)
{}
i
i + 976
i + 876
paste("", i + 876)
paste("tnt_log.", i + 876, ".txt", collapse = "")
paste("tnt_log.", i + 876, ".txt", sep = "")
paste("tnt_log.", i, ".txt", sep = "")
for(i in 0:123) file.rename(from = paste("tnt_log.", i, ".txt", sep = ""), to = paste("tnt_log.", i + 876, ".txt", sep = ""))
for(i in 0:123) file.rename(from = paste("trees_tnt.", i, ".txt", sep = ""), to = paste("trees_tnt.", i + 876, ".txt", sep = ""))
for(i in 0:123) file.rename(from = paste("trees_tnt.", i, ".tnt", sep = ""), to = paste("trees_tnt.", i + 876, ".tnt", sep = ""))
?read.csv
read.table(file = file.choose())
# Load libraries:#
library(ape)#
#
# Set working directoyr to where tnt output resides:#
setwd("/Users/eargtl")#
#
# Get a list of the tree files found there:#
treefiles <- list.files()[grep("trees_tnt", list.files())]#
#
# Create empty lists to store results for each file:#
AllTrees <- AllTreeLengths <- list()#
#
# For every log file for which trees exist:#
for(i in sort(as.numeric(unlist(lapply(strsplit(treefiles, "trees_tnt|\\."), '[[', 3))))) {#
    # Build path to and read in current log file:#
    currentlogfile <- readLines(paste("tnt_log.", i, ".txt", sep = ""))#
    # Begin to whittle down to just the tree lengths by finding block that contains them:#
    treelengths <- currentlogfile[(grep("Tree lengths", currentlogfile) + 1):(grep("COMMAND: LOG", currentlogfile) - 1)]#
    # Collapse to only-non-empty lines:#
    treelengths <- treelengths[lapply(lapply(strsplit(treelengths, " "), nchar), sum) > 0]#
    # Remove top line:#
    treelengths <- treelengths[2:length(treelengths)]#
    # Trim ends away:#
    treelengths <- gdata::trim(treelengths)#
    # Remove leading count to just get tree lengths in order:#
    treelengths <- as.numeric(unlist(lapply(strsplit(treelengths, " "), '[', -1)))#
    # Store tree lengths in list:#
    AllTreeLengths[[(i + 1)]] <- treelengths#
}#
#
# For each tree file:#
for(i in 0:(length(treefiles) - 1)) {#
    # Build path to tree file and read in:#
    currenttreefile <- readLines(paste("trees_tnt.", i, ".tnt", sep = ""))#
    # Get just the tree lines:#
    treelines <- currenttreefile[unlist(lapply(strsplit(currenttreefile, ""), '[[', 1)) == "("]#
    # Update ending of Newick string to semicolon:#
    treelines <- gsub("*", ";", treelines, fixed = TRUE)#
    # Update spaces to commas to move towards Newick format:#
    treelines <- gsub(" ", ",", treelines, fixed = TRUE)#
    # Add commas between clades to get to Newick format:#
    treelines <- gsub(")(", "),(", treelines, fixed = TRUE)#
    # Remove commas before close parantheses to get to Newick format:#
    treelines <- gsub(",)", ")", treelines, fixed = TRUE)#
    # Actually read in formatted data as tree files using ape:#
    Trees <- read.tree(text = treelines)#
    # Store tree files:#
    AllTrees[[(i + 1)]] <- Trees#
}#
#
# Convert all tree lengths to vector:#
AllTreeLengths <- unlist(AllTreeLengths)#
#
# Create empty new all trees to combine as a multiphylo object:#
NewAllTrees <- list()#
#
# For each tree file:#
for(i in 1:length(AllTrees)) {#
    # Store each indiviudal tree after ladderising it:#
    for(j in 1:length(AllTrees[[i]])) NewAllTrees[[(length(NewAllTrees) + 1)]] <- ladderize(AllTrees[[i]][[j]])#
}#
#
# Update to class multiPhylo:#
class(NewAllTrees) <- "multiPhylo"#
#
# Collapse to just minimum length trees:#
NewAllTrees <- NewAllTrees[which(AllTreeLengths == min(AllTreeLengths))]#
#
# Collapse to just unique trees:#
NewAllTrees <- read.tree(text = unique(write.tree(NewAllTrees)))#
#
# Get strict component consensus:#
SCC <- ladderize(consensus(NewAllTrees))
# Write out MPTs:#
write.tree(NewAllTrees, "/Users/eargtl/MPTs.tre")#
#
# Write out strict component consensus:#
write.tree(SCC, "/Users/eargtl/SCC.tre")
NewAllTrees
runif(1000, 0, 1)
x <- runif(1000, 0, 1)
hist(x)
y <- x[1:100]
z <- x[101:1000]
hist(y)
?hist
hist(z, new = FALSE)
?plot
hist(y)
hist(y, col = "red")
hist(z, add = TRUE, col = "blue")
hist(z, col = "red")
hist(y, add = TRUE, col = "blue")
?rgb
install.packages("gdata", dependencies = TRUE)
install.packages("strap", dependencies = TRUE)
?read
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(strap)
?read.tree
# Read in trees:#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")
MostParsimoniousTrees
MostParsimoniousTrees[[1]]
?gdata
TraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")
TraitsData[1:2, ]
AllTraitsData
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(strap)#
#
# Read in trees:#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")
AllTraitsData[1:2, c"TaxonName", "Max", "Min")]
AllTraitsData[1:2, c("TaxonName", "Max", "Min")]
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]
AgeData
AgeData[, "Max"]
is.na(AgeData[, "Max"])
cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"]))
apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, all)
?all
apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any)
!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any)
AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]
AgeData[, "TaxonName"]
as.character(AgeData[, "TaxonName"])
setdiff(as.character(AgeData[, "TaxonName"]), FirstMostParsimoniousTree$tip.label)
setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]
setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees:#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)
?timePaleoPhy
as.numeric(AgeData[, "FAD"])
AgeData[1, ]
as.numeric(AgeData[, "Max"])
c(as.numeric(AgeData[, "Max"], as.numeric(AgeData[, "Min"])
)
c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"]))
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2)
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))[1:2, ]
?timePaleoPhy
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
plot(FirstMostParsimoniousTree, show.tip.label=FALSE)
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Ladderize the tree to ake it prettier/easier to read:#
FirstMostParsimoniousTree <- ladderize(FirstMostParsimoniousTree)#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
# Ladderize the tree to ake it prettier/easier to read:#
FirstMostParsimoniousTree <- ladderize(FirstMostParsimoniousTree)#
#
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
FirstMostParsimoniousTree
FirstMostParsimoniousTree$edge.length
plot(FirstMostParsimoniousTree, show.tip.label = FALSE)
#geoscalePhylo(tree = FirstMostParsimoniousTree)
?geoscalePhylo(tree
?geoscalePhylo
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 0.5)#
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
?timePaleoPhy
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "equal", vartime = 1)#
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf")#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 50)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 65)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
?geoscalePhylo
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree, x.lim = c(252, 66))#
dev.off()
?geoscalePhylo
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree, x.lim = c(252, 66), cex.age = 1, cex.ts = 1, cex.tip = 0.3)#
dev.off()
"(1);"
list("(1);")
N<-3
# Build start tree (Newick but with numbers of taxa only):#
    StartTree <- list("(1);")#
    i <- 2#
    NInternalNodes <- max(c(1, i - 1))#
    # For each level of resolution (from one internal node to N - 1 internal nodes):#
    for(j in 1:NInternalNodes) {#
      # If adding a new internal node begin by populating new level with tree(s) from lower level:#
      if(j > length(StartTree)) StartTree[[j]] <- StartTree[[(j - 1)]]#
    }
StartTree
N
# Build start tree (Newick but with numbers of taxa only):#
    StartTree <- list("(1);")#
    # REPLACE WITH FOR LOOP EVENTUALLY:#
    i <- N#
    NInternalNodes <- max(c(1, i - 1))#
    # For each level of resolution (from one internal node to N - 1 internal nodes):#
    for(j in 1:NInternalNodes) {#
      # If adding a new internal node begin by populating new level with tree(s) from lower level:#
      if(j > length(StartTree)) StartTree[[j]] <- StartTree[[(j - 1)]]#
    }
StartTree[[j]]
gsub("(", "", StartTree[[j]])
gsub("\\(", "", StartTree[[j]])
gsub("\\(|)", "", StartTree[[j]])
gsub("\\(|)|;", "", StartTree[[j]])
StartTree[[j]]
strsplit("", StartTree[[j]])[[1]]
j
j<-1
strsplit("", StartTree[[j]])[[1]]
StartTree[[j]]
strsplit("", StartTree[[j]])
strsplit(StartTree[[j]], "")
strsplit(StartTree[[j]], "")[[1]]
strsplit(StartTree[[j]], "")[[1]] == "("
sum(strsplit(StartTree[[j]], "")[[1]] == "(")
lapply(StartTree[[j]], strsplit, split = "")
lapply(lapply(StartTree[[j]], strsplit, split = ""), unlist)
SplitString <- lapply(lapply(StartTree[[j]], strsplit, split = ""), unlist)
SplitSTring
SplitString
lapply(SplitString, function(x) which(x == ",") - 1))
lapply(SplitString, function(x) which(x == ",") - 1)
CommaNumberFinder <- function(x) {#
        BeforeComma <- which(x == ",") - 1#
        BeforeComma#
      }#
      lapply(SplitString, CommaNumberFinder)
BeforeComma
SplitString[[1]]
x <- SplitString[[1]]
BeforeComma <- 2
x[BeforeComma]
is.numeric(x[BeforeComma])
as.numeric(x[BeforeComma])
is.numeric(as.numeric(x[BeforeComma]))
BeforeComma[is.numeric(as.numeric(x[BeforeComma]))]
x <- c("(", "1", ",", "(", "1", ",", "(", "2", ")", ")", ")", ";")
x
BeforeComma <- which(x == ",") - 1#
        # Isolate#
        CommaNumbers <- BeforeComma[is.numeric(as.numeric(x[BeforeComma]))]#
        return(CommaNumbers)
CommaNumberFinder
CommaNumbers
x
strsplit("((2),(2));", "")
strsplit("((2),(2));", "")[[1]]
x <- strsplit("((2),(2));", "")[[1]]
BeforeComma <- which(x == ")") - 1#
        # Isolate#
        CommaNumbers <- BeforeComma[is.numeric(as.numeric(x[BeforeComma]))]
BeforeComma
as.numeric(x[BeforeComma])
x[BeforeComma]
BeforeComma <- which(x == ",") - 1#
        # Isolate#
        CommaNumbers <- BeforeComma[is.numeric(as.numeric(x[BeforeComma]))]
x[BeforeComma]
TRUE + FALSE
x[BeforeComma]
x[BeforeComma] == "("
x[BeforeComma] == ")"
BeforeComma[]!x[BeforeComma] == ")"]
BeforeComma[!x[BeforeComma] == ")"]
x
# Get positions before a comma in string:#
        BeforeComma <- which(x == ",") - 1#
        # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses the only other option):#
        CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]
CommaNumbers
SplitString
##
      CommaNumberFinder <- function(x) {#
        # Get positions before a comma in string:#
        BeforeComma <- which(x == ",") - 1#
        # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
        CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]#
        # Output positions of numbers followed by a comma (if any):#
        return(CommaNumbers)#
      }#
      CommaNumbers <- lapply(SplitString, CommaNumberFinder)#
      ParentheticNumberFinder <- function(x) {#
        # Get positions before a close parenthesis in string:#
        BeforeClosingParenthesis <- which(x == ")") - 1#
        # Isolate just parentheses that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
        ParenthesisNumbers <- BeforeClosingParenthesis[!x[BeforeClosingParenthesis] == ")"]#
        return(ParenthesisNumbers)#
      }#
      ParenthesisNumbers <- lapply(SplitString, CommaNumberFinder)
ParenthesisNumber
ParenthesisNumbers
x <- SplitString
# Get positions before a close parenthesis in string:#
        BeforeClosingParenthesis <- which(x == ")") - 1
BeforeClosingParenthesis
x
x == ")"
##
      CommaNumberFinder <- function(x) {#
        # Get positions before a comma in string:#
        BeforeComma <- which(x == ",") - 1#
        # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
        CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]#
        # Output positions of numbers followed by a comma (if any):#
        return(CommaNumbers)#
      }#
      CommaNumbers <- lapply(SplitString, CommaNumberFinder)#
      ParentheticNumberFinder <- function(x) {#
        # Get positions before a close parenthesis in string:#
        BeforeClosingParenthesis <- which(x == ")") - 1#
        # Isolate just parentheses that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
        ParenthesisNumbers <- BeforeClosingParenthesis[!x[BeforeClosingParenthesis] == ")"]#
        return(ParenthesisNumbers)#
      }#
      ParenthesisNumbers <- lapply(SplitString, ParentheticNumberFinder)
ParenthesisNumbers
N
list("(3);", "(1,(2));")
StartTree <- list("(3);", "(1,(2));")#
    N <- 4#
    # REPLACE WITH FOR LOOP EVENTUALLY:#
    i <- 4 #for(i in in 2:N) {#
    NInternalNodes <- max(c(1, i - 1))
NInternalNodes
paste("(", i, ");)")")
paste("(", i, ");)")
paste("(", i, ");")
paste("(", i, ");", collapse = "")
paste("(", i, ");", sep = "")
StartTree <- list("(3);", "(1,(2));")#
    N <- 4#
    # REPLACE WITH FOR LOOP EVENTUALLY:#
    i <- 4 #for(i in in 2:N) {#
    NInternalNodes <- max(c(1, i - 1))#
    # For each level of resolution (from one internal node to N - 1 internal nodes):#
    for(j in 1:NInternalNodes) {#
      # If dealing with a single (root) node:#
      if(j == 1) {#
        # Update single node start tree to just N in parentheses:#
        StartTree[[j]] <- paste("(", i, ");", sep = "")#
      # If dealing with at least two internal nodes:#
      } else {#
        # If adding a new internal node begin by populating new level with tree(s) from lower level:#
        if(j > length(StartTree)) StartTree[[j]] <- StartTree[[(j - 1)]]#
        # Find out current number of internal nodes:#
        CurrentInternalNodeCount <- sum(strsplit(StartTree[[j]], "")[[1]] == "(")#
        # Build out split strings (each character an item in a vector):#
        SplitString <- lapply(lapply(StartTree[[j]], strsplit, split = ""), unlist)#
        # Subfunction to find and "comma" numbers (unique restrictions apply):#
        CommaNumberFinder <- function(x) {#
          # Get positions before a comma in string:#
          BeforeComma <- which(x == ",") - 1#
          # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
          CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]#
          # Output positions of numbers followed by a comma (if any):#
          return(CommaNumbers)#
        }#
        # Get positions of numbers followed by a comma (if any):#
        CommaNumbers <- lapply(SplitString, CommaNumberFinder)#
        # Subfunction to find and "parenthesis" numbers (unique restrictions apply):#
        ParentheticNumberFinder <- function(x) {#
          # Get positions before a close parenthesis in string:#
          BeforeClosingParenthesis <- which(x == ")") - 1#
          # Isolate just parentheses that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
          ParenthesisNumbers <- BeforeClosingParenthesis[!x[BeforeClosingParenthesis] == ")"]#
          # Output positions of numbers inside parentheses:#
          return(ParenthesisNumbers)#
        }#
        # Get positions of numbers inside parentheses:#
        ParenthesisNumbers <- lapply(SplitString, ParentheticNumberFinder)#
        # Case if no internal nodes need to be added:#
        if(CurrentInternalNodeCount == j) {#
          # KEEP NODE COUNT THE SAME#
        # Case if new internal node needs to be added (changes how addition works):#
        } else {#
          # ONLY ADD NEW NODE#
        }#
      }#
    }
StartTree
# Build start tree (Newick but with numbers of taxa only):#
    StartTree <- list("(1);")#
    StartTree <- list("(3);", "(1,(2));")#
    N <- 4
# Build start tree (Newick but with numbers of taxa only):#
    StartTree <- list("(1);")#
    StartTree <- list("(3);", "(1,(2));")#
    N <- 4#
    # REPLACE WITH FOR LOOP EVENTUALLY:#
    i <- 4 #for(i in in 2:N) {#
    NInternalNodes <- max(c(1, i - 1))
j <- 2
# If adding a new internal node begin by populating new level with tree(s) from lower level:#
        if(j > length(StartTree)) StartTree[[j]] <- StartTree[[(j - 1)]]#
        # Build out split strings (each character an item in a vector):#
        SplitString <- lapply(lapply(StartTree[[j]], strsplit, split = ""), unlist)#
        # Subfunction to find and "comma" numbers (unique restrictions apply):#
        CommaNumberFinder <- function(x) {#
          # Get positions before a comma in string:#
          BeforeComma <- which(x == ",") - 1#
          # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
          CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]#
          # Output positions of numbers followed by a comma (if any):#
          return(CommaNumbers)#
        }#
        # Get positions of numbers followed by a comma (if any):#
        CommaNumbers <- lapply(SplitString, CommaNumberFinder)#
        # Subfunction to find and "parenthesis" numbers (unique restrictions apply):#
        ParentheticNumberFinder <- function(x) {#
          # Get positions before a close parenthesis in string:#
          BeforeClosingParenthesis <- which(x == ")") - 1#
          # Isolate just parentheses that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
          ParenthesisNumbers <- BeforeClosingParenthesis[!x[BeforeClosingParenthesis] == ")"]#
          # Output positions of numbers inside parentheses:#
          return(ParenthesisNumbers)#
        }#
        # Get positions of numbers inside parentheses:#
        ParenthesisNumbers <- lapply(SplitString, ParentheticNumberFinder)
CommaNumbers
StartTree
lapply(lapply(StartTree[[j]], strsplit, split = ""), unlist)
SplitString
lapply(SplitString, paste, sep = "")
lapply(SplitString, paste, collapse = "")
# Subfunction to find and "comma" numbers (unique restrictions apply):#
  CommaNumberFinder <- function(x) {#
    # Get positions before a comma in string:#
    BeforeComma <- which(x == ",") - 1#
    # Isolate just commas that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
    CommaNumbers <- BeforeComma[!x[BeforeComma] == ")"]#
    # Output positions of numbers followed by a comma (if any):#
    return(CommaNumbers)#
  }#
  # Subfunction to find and "parenthesis" numbers (unique restrictions apply):#
  ParentheticNumberFinder <- function(x) {#
    # Get positions before a close parenthesis in string:#
    BeforeClosingParenthesis <- which(x == ")") - 1#
    # Isolate just parentheses that follow a number (i.e., those that do not follow a close parentheses, the only other option):#
    ParenthesisNumbers <- BeforeClosingParenthesis[!x[BeforeClosingParenthesis] == ")"]#
    # Output positions of numbers inside parentheses:#
    return(ParenthesisNumbers)#
  }
SplitString
SplitString[[1]]
x <- SplitString[[1]]
# Get positions of numbers followed by a comma (if any):#
          CommaPostitions <- CommaNumberFinder(x)#
          # Get positions of numbers inside parentheses:#
          ParenthesisPositions <- ParentheticNumberFinder(x))
# Get positions of numbers followed by a comma (if any):#
          CommaPostitions <- CommaNumberFinder(x)#
          # Get positions of numbers inside parentheses:#
          ParenthesisPositions <- ParentheticNumberFinder(x)
CommaPostitions
ParenthesisPositions
?c
install.packages("devtools", dependencies = TRUE)#
devtools::install_github("graemetlloyd/Claddis")#
library(Claddis)#
?DiscreteCharacterRate
library(CLaddis)
library(Claddis)
?Claddis
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
# chirality whther spiral is left- ("Sinistral") or right-handed ("Dextral")#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180, chirality = "Sinistral") {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # If chirality is dextral multiply all x values by -1 (makes it a dextral spiral):#
    if(chirality == "Dextral") x <- x * -1#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (or first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Short function to convert maximum diameter into a radius:#
AmmoniteMaxDiameterToMaxRadius <- function(x) x * 0.6130215#
#
# Function to get dividing walls between chambers for binning later:#
ChamberPositions  <- function(chamber_exponent = 1.14, N_chambers = 30, N_points = 10000, r_max = AmmoniteMaxDiameterToMaxRadius(250)) {#
  ChamberwallRadii <- (round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers)))) / N_points) * r_max#
  LogChamberwallRadii <- log(ChamberwallRadii)#
  DividingWalls <- exp((LogChamberwallRadii[2:length(LogChamberwallRadii)] + LogChamberwallRadii[1:(length(LogChamberwallRadii) - 1)]) / 2)#
  return(DividingWalls)#
}#
#
# Set dividing walls between chamber counts (i.e., for deciding chamber count given a diameter value):#
DividingWalls <- ChamberPositions()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set chirality of ammonites:#
        Chirality <- sample(x = c("Sinistral", "Dextral"), size = N_ammonites, replace = TRUE)#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Set N chambers based on ammonite sizes:#
        N_chambers <- unlist(lapply(as.list(ammonite_sizes), function(x) sum(x > DividingWalls) + 1))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) {#
          # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
          ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
          # Set N chambers based on ammonite sizes:#
          N_chambers <- unlist(lapply(as.list(ammonite_sizes), function(x) sum(x > DividingWalls) + 1))#
        }#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i], chirality = Chirality[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Empty plot (second page for two-sided printing):#
        plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0, 100), ylim = c(0, 100))#
        # Add horizontal lines for table:#
        lapply(as.list(seq(from = 0, to = 100, length.out = 22)), function(x) lines(x = c(0, 100), y = c(x, x)))#
        # Add vertical lines for table:#
        lapply(as.list(seq(from = 0, to = 100, length.out = 5)), function(x) lines(x = c(x, x), y = c(0, 100)))#
        # Add values for first column:#
        for(i in 1:21) text(x = 12.5, y = seq(from = 0, to = 100, length.out = 22)[i] + 4, labels = rev(c("#", as.character(1:20)))[i], pos = 1, cex = 1.3)#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings, Chirality)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees", "Chirality")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[intersect(grep(".csv", list.files()), grep("Quadrat_", list.files()))]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 8, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees", "Chirality")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
colnames(AllQuadrats)[1] <- "Quadrat"#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/AllQuadrats.csv", row.names = FALSE)#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 11.69, width = 8.27)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Set N chambers based on ammonite sizes:#
    N_chambers <- unlist(lapply(as.list(ammonite_sizes), function(x) sum(x > DividingWalls) + 1))#
    # Make sure there are at least five different chamber numbers in the sample and that no ammonite is smaller than 10 mm:#
    while(length(unique(N_chambers)) < 4 || min(ammonite_sizes) < 10) {#
      # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
      ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
      # Set N chambers based on ammonite sizes:#
      N_chambers <- unlist(lapply(as.list(ammonite_sizes), function(x) sum(x > DividingWalls) + 1))#
    }#
    # Set chirality of ammonites:#
    Chirality <- sample(x = c("Sinistral", "Dextral"), size = N_ammonites, replace = TRUE)#
#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n", asp = 1)#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i], chirality = Chirality[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Add customised code to plot:#
    text(x = -80, y = 500, labels =#
    paste(#
    "# It is recommended that you begin by downloading the digital version of this quadrat, available here:\n",#
    paste("browseURL(\"http://www.graemetlloyd.com/teaching/SOEE1470/19/Upper_Bed/", X, Y, ".pdf\")\n", sep = ""),#
    "\n",#
    "# This will make it easier for you to simply copy and paste the lines below instead of typing them out\n",#
    "# yourself.\n",#
    "#\n",#
    "# For this assessment quadrat the measurements have already been done for you. DO NOT measure the data\n",#
    "# yourself as you will be assessed on the measurements you are given. For this quadrat the data can be\n",#
    "# imported into R with:\n",#
    paste("AssessmentQuadratData = read.csv(\"http://www.graemetlloyd.com/teaching/SOEE1470/19/Upper_Bed/Quadrat_", X, Y, ".csv\")\n", sep = ""),#
    "\n",#
    "# The column names for the data indicate what is available:\n",#
    "colnames(AssessmentQuadratData)\n",#
    "\n",#
    "# Thus, you can get the ammmonite number with:\n",#
    "AssessmentQuadratData[, \"Ammonite_number\"]\n",#
    "\n",#
    "# The x coordinates with:\n",#
    "AssessmentQuadratData[, \"X_coordinate\"]\n",#
    "\n",#
    "# The y coordinates with:\n",#
    "AssessmentQuadratData[, \"Y_coordinate\"]\n",#
    "\n",#
    "# The diameters with:\n",#
    "AssessmentQuadratData[, \"Diameter_mm\"]\n",#
    "\n",#
    "# The chamber count with:\n",#
    "AssessmentQuadratData[, \"N_chambers\"]\n",#
    "\n",#
    "# And the aperture bearing with:\n",#
    "AssessmentQuadratData[, \"Aperture_bearing_degrees\"]\n",#
    "\n",#
    "# NB: The chirality it is not required here and can be ignored.\n",#
    sep = ""), family = "mono", pos = 4, cex = 0.7)#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings, Chirality)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees", "Chirality")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[intersect(grep(".csv", list.files()), grep("Quadrat_", list.files()))]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 8, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees", "Chirality")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
colnames(AllQuadrats)[1] <- "Quadrat"#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/AllQuadrats.csv", row.names = FALSE)
