# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]
AgeData
AgeData[, "Max"]
is.na(AgeData[, "Max"])
cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"]))
apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, all)
?all
apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any)
!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any)
AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]
AgeData[, "TaxonName"]
as.character(AgeData[, "TaxonName"])
setdiff(as.character(AgeData[, "TaxonName"]), FirstMostParsimoniousTree$tip.label)
setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]
setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees:#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))
drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)
?timePaleoPhy
as.numeric(AgeData[, "FAD"])
AgeData[1, ]
as.numeric(AgeData[, "Max"])
c(as.numeric(AgeData[, "Max"], as.numeric(AgeData[, "Min"])
)
c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"]))
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2)
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))
matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))[1:2, ]
?timePaleoPhy
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, as.character(AgeData[, "TaxonName"]))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Install packages required for analysis only need to do this once):#
install.packages("gdata", dependencies = TRUE)#
install.packages("paleotree", dependencies = TRUE)#
install.packages("strap", dependencies = TRUE)#
#
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
plot(FirstMostParsimoniousTree, show.tip.label=FALSE)
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Ladderize the tree to ake it prettier/easier to read:#
FirstMostParsimoniousTree <- ladderize(FirstMostParsimoniousTree)#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
# Load libraries into memory (need to do this at start of each R session):#
library(gdata)#
library(paleotree)#
library(strap)#
#
# Read in trees (may need to modify this path slightly for your own machine):#
MostParsimoniousTrees <- read.tree(file = "~/Dropbox/Literature Search/Tree search results/Dinosauria_MPTs_Full.tre")#
#
# Isolate just the first tree (will use this for analysis as first pass relationships look better than some other trees):#
FirstMostParsimoniousTree <- MostParsimoniousTrees[[1]]#
#
# Read in traits data Excel spreadsheet:#
AllTraitsData <- read.xls(xls = "~/Dropbox/Literature Search/Metatree Files/Traits.xlsx")#
#
# Isolate just the age data:#
AgeData <- AllTraitsData[, c("TaxonName", "Max", "Min")]#
#
# Remove any NA values so age data only contains taxa with age data:#
AgeData <- AgeData[!apply(cbind(is.na(AgeData[, "Max"]), is.na(AgeData[, "Min"])), 1, any), ]#
#
# Format age data further ready for use in time-scaling (two columns of "FAD" and "LAD" dates and row names corresponding to taxa):#
AgeData <- matrix(c(as.numeric(AgeData[, "Max"]), as.numeric(AgeData[, "Min"])), ncol = 2, dimnames = list(as.character(AgeData[, "TaxonName"]), c("FAD", "LAD")))#
#
# Find any tips without age data on the tree that will need to be pruned:#
TipsToPruneDueToMissingAgeData <- setdiff(FirstMostParsimoniousTree$tip.label, rownames(AgeData))#
#
# If there are tips to prune remove these from the first most parsimonious tree:#
if(length(TipsToPruneDueToMissingAgeData) > 0) FirstMostParsimoniousTree <- drop.tip(phy = FirstMostParsimoniousTree, tip = TipsToPruneDueToMissingAgeData)#
#
# Ladderize the tree to ake it prettier/easier to read:#
FirstMostParsimoniousTree <- ladderize(FirstMostParsimoniousTree)#
#
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 1)
FirstMostParsimoniousTree
FirstMostParsimoniousTree$edge.length
plot(FirstMostParsimoniousTree, show.tip.label = FALSE)
#geoscalePhylo(tree = FirstMostParsimoniousTree)
?geoscalePhylo(tree
?geoscalePhylo
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
# Time-scale tree by using a minimum branch length of 1 million years:#
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "mbl", vartime = 0.5)#
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
?timePaleoPhy
FirstMostParsimoniousTree <- timePaleoPhy(tree = FirstMostParsimoniousTree, timeData = AgeData, type = "equal", vartime = 1)#
geoscalePhylo(tree = FirstMostParsimoniousTree, show.tip.label = FALSE)
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf")#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 50)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 65)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree)#
dev.off()
?geoscalePhylo
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree, x.lim = c(252, 66))#
dev.off()
?geoscalePhylo
pdf("~/Dropbox/Literature Search/R Analysis/TimeScaledTree.pdf", width = 10, height = 75)#
geoscalePhylo(tree = FirstMostParsimoniousTree, x.lim = c(252, 66), cex.age = 1, cex.ts = 1, cex.tip = 0.3)#
dev.off()
# R is a statistical programming language and can be used in a number of ways.#
# First of all it can do basic calculations:#
1 + 2#
#
# You should see the answer 3 appear (if not try hitting enter). Now try#
# yourself by typing something else (NB: * is used for multiply and / for#
# divide):#
# Most of the time we will not want to print our answer to the screen, but#
# store it in something called a VARIABLE (basically a "bucket" in which data#
# resides). (Note that this is the computing sense of the word and during this#
# course we will also encounter a separate statistical meaning - any#
# characteristic, number, or quantity that can be measured or counted):#
x <- 1 + 2#
#
# Here our variable is named "x" and the arrow "<-" indicates that the data on#
# the right (1 + 2) is being stored in it. Note that this time nothing will#
# happen after hitting enter because no other response is required. We can see#
# the contents of our variable at any time by typing its' name:#
x#
#
# This time you should see the answer again (3). We can always modify and#
# update our variable by performing a calculation on it and overwriting it#
# with the answer. For example, we can multiply (using the "*" symbol) it by#
# 2 by typing:#
x <- x * 2#
#
# Again, no response will be given, so we can type it again to check it has#
# gotten the correct answer (6):#
x#
#
# Note that R will NEVER warn you if you try and overwrite a variable so good#
# practice is to use a new name each time. Furthermore, it is best to use#
# more descriptive names (avoid "x", "y" etc.) and also avoid names that are#
# already used by basic R functions (mean, table etc.). We can also use#
# variables to store more complex forms of data, such as vectors:#
TyrannosaurBodyMasses <- c(2013, 627, 276, 889, 2710, 605, 3215, 17, 1027,#
  2487, 72, 494, 699, 44, 2539, 3018, 2345, 947, 51, 7694, 172)#
#
# A VECTOR can be thought of as a single row or column of data and can be#
# entered directly into R, as we have done here, using the combine#
# FUNCTION "c". Functions are the "doing" parts of R and are usually#
# indicated by their name (here "c") followed by parentheses ("()") which#
# contain data or other options separated by commas. In this case we only#
# have data - a series of body mass estimates for tyrannosaurid dinosaurs in#
# kilograms - and we are storing ("<-") this data in an appropriately named#
# variable ("TyrannosaurBodyMasses"). Again, we can view the contents by#
# typing its' name:#
TyrannosaurBodyMasses#
#
# It's worth noting here that data in R can be of fundamentally different#
# types. Normally either numeric (numbers) or characters (text, also termed#
# "strings"). We can make sure our data is numeric by using another function,#
# is.numeric():#
is.numeric(TyrannosaurBodyMasses)#
#
# Note that we are giving only one thing to this function, the name of the#
# variable we want to be checked. This is a logical function - there are#
# only two possible answers, TRUE or FALSE. You should see the answer "TRUE".#
# However, our data set is incomplete as we only have a series of body masses#
# and no indication which particular type of dinosaur each corresponds to. To#
# add this information we could convert our data into a table with two columns#
# (species name and body mass). However, this can be problematic as it would#
# involve mixing two different data types (character and numeric, respectvely).#
# Besides which, R already has a built in structure for adding names to data:#
names(TyrannosaurBodyMasses)#
#
# The "names" function returns the names assigned to a vector. Here you should#
# get the answer "NULL" which is R for "this has not been set or is missing".#
# We can set the names by typing the following:#
names(TyrannosaurBodyMasses) <- c("Albertosaurus_sarcophagus",#
  "Alectrosaurus_olseni", "Alioramus_spp", "Appalachiosaurus_montgomeriensis",#
  "Daspletosaurus_torosus", "Daspletosaurus_torosus", "Daspletosaurus_torosus",#
  "Dilong_paradoxus", "Dryptosaurus_aquilunguis", "Gorgosaurus_libratus",#
  "Guanlong_wucaii", "Juratyrant_langhami", "Qianzhousaurus_sinensis",#
  "Raptorex_kriegsteini", "Tarbosaurus_bataar", "Tarbosaurus_bataar",#
  "Tarbosaurus_bataar", "Teratophoneus_curriei", "Timimus_hermani",#
  "Tyrannosaurus_rex", "Xiongguanlong_baimoensis")#
#
# Note that we still use names() and not just the variable name as we want to#
# store this text as the names for each item in the vector and not overwrite#
# the body masses themselves. We can check these names are now set by using the#
# names function again:#
names(TyrannosaurBodyMasses)#
#
# Note that these names are in "snake case", which is a coding term for using#
# underscores ("_") to separate words in a text string (series of characters).#
# The common alternative to this is to use "camel case", where each word begins#
# with a capital, like our variable name ("TyrannosaurBodyMasses"). The reason#
# why this is done is names with spaces are not generally allowed in computing,#
# e.g., try:#
Tyrannosaur Body Masses <- c(2013, 627, 276, 889, 2710, 605, 3215, 17, 1027,#
  2487, 72, 494, 699, 44, 2539, 3018, 2345, 947, 51, 7694, 172)#
#
# You should get an error message as R does not understand what you want it to#
# do. More generally you will find that R (or any programming language) requires#
# very specifically formatted instructions in order to process them. (This is#
# why you are copying and pasting from this script!)#
##
# The next thing we should learn now that we have a more complex variable type#
# is how to access only part of it. This is done by using square brackets ("[]")#
# after the variable name. So to get the fifth body mass from our data we can#
# type:#
TyrannosaurBodyMasses[5]#
#
# Or the second to tenth:#
TyrannosaurBodyMasses[2:10]#
#
# Or the third, fifth, and ninth:#
TyrannosaurBodyMasses[c(3, 5, 9)]#
#
# Note that we have here learned to use the colon to get a sequence of values#
# (2:10) and the combine function ("c()") again to give a series of specific#
# values. However, good practice is to use our names and subset the data not#
# with numbers but with text (which should always appear in quotes, ""). This is#
# because data can be reordered or modified, meaning the second value (for example)#
# can change, but the names should continue to be attached to the correct value. We#
# can get the body mass for Tyrannosaurus rex with:#
TyrannosaurBodyMasses["Tyrannosaurus_rex"]
browseURL("http://www.graemetlloyd.com/teaching/SOEE1470/18/NOAAVolcanoDatabase.xlsx")
browseURL("http://www.graemetlloyd.com/teaching/SOEE1470/18/NOAAVolcanoDatabase.xlsx")
install.packages("gdata", dependencies = TRUE)
# (If you are prompted to use a personal directory just click yes.) This might#
# take a few seconds to work, but you should see some text and a status bar.#
# Now this package should be permanentally installed on your machine the next#
# task is to load it (and its' functions) into memory:#
library(gdata)
# Here we use the function "library()" that simply loads a package (aka library)#
# into memory. We can now use the function "read.xls()" to read in our volcano#
# data. We will store ("<-") this in a new variable ("VolcanoData"), but we#
# also need to supply read.xls with the filepath to our data. Here we will do#
# this using the "file.choose()" function which will load a file explorer much#
# as you would do with GUI software. Navigate to where you downloaded the data#
# and select the Excel file:#
VolcanoData <- read.xls(file.choose())
# This has imported the data as a TABLE (i.e., with rows and columns). You#
# should find it has automatically recognised the headers:#
colnames(VolcanoData)#
#
# This should return the headers from the Excel file. Note that "colnames()"#
# functions like "names()" did for vectors, but with the added "col" part to#
# indicate columns. There are row names too:#
rownames(VolcanoData)
# Like vectors we can also use square brackets to isolate only part of the#
# data. For example, just the latitudes:#
VolcanoData[, "Latitude"]
# Note that this time the square brackets must contain a comma. This separates#
# row values (before the comma) from column values (after the comma). We don't#
# provide a row value here so it defaults to giving us all rows. We can reuse#
# our tricks with vectors to get, say, the first 100 latitudes:#
VolcanoData[1:100, "Latitude"]
# We may also want to access just part of the data. For example, there are many#
# different kinds of volcano. We can see just how many by taking the unique#
# values in our "Type" column:#
unique(VolcanoData[, "Type"])
# Here we use the "unique()" function to remove any duplicates. Now let's find#
# which values in the "Type" column are stratovolcanoes:#
which(VolcanoData[, "Type"] == "Stratovolcano")
# This is a more complex function ("which()") that returns any values that are#
# logically TRUE from the statement VolcanoData[, "Type"] == "Stratovolcano".#
# I.e., any value for "Type" that equals ("==") "Stratovolcano". Note that a#
# double equals is used here because "=" on its own is reserved for storing#
# data in a variable:#
x = 3#
x#
#
# "<-" is preferable though as it avoids confusion with mathematical statements#
# and clearly shows (as it forms an arrow) what is being stored where. Now that#
# we have a means of showing which volcanoes are stratovolcanoes we can look at#
# just those rows using:#
VolcanoData[which(VolcanoData[, "Type"] == "Stratovolcano"), ]
# This is still a pretty large list, but it includes many iconic volcanoes#
# (e.g., Fuji, St Helens). We could also get just a specific volcano using its'#
# name. So for Fuji:#
VolcanoData[which(VolcanoData[, "Volcano.Name"] == "Fuji"), ]
# Note that, again, we have to use the *exact* name. None of these will work:#
VolcanoData[which(VolcanoData[, "Volcano.Name"] == "fuji"), ]#
VolcanoData[which(VolcanoData[, "Volcano.Name"] == "Mt Fuji"), ]#
VolcanoData[which(VolcanoData[, "Volcano.Name"] == "Mount Fuji"), ]
# You should now have a basic grasp of how R operates, but we have not yet#
# encountered its' true strength: plotting data. We now have two data sets in#
# memory to play with so let's do some simple visualisations. First of all, we#
# will look at our Tyrannosaur data. Note that this is UNIVARIATE data - i.e.,#
# it concerns only a single type of measurement. This is best plotted using#
# either a histogram or a boxplot. For a histogram we can just type:#
hist(TyrannosaurBodyMasses)
# And for a boxplot:#
boxplot(TyrannosaurBodyMasses)
browseURL("https://support.office.com/en-gb/article/create-a-box-plot-10204530-8cdf-40fe-a711-2eb9785e510f")#
#
# Or a histogram:#
browseURL("https://support.microsoft.com/en-gb/help/214269/how-to-use-the-histogram-tool-in-excel")
# These are just two of many reasons why R is the right tool for the job. But#
# let's get back to looking at these plots:#
hist(TyrannosaurBodyMasses)
# The histogram automatically "bins" our data (here into 1000 Kg widths) and#
# then counts the number of values in each bin ("Frequency" on the y-axis).#
# You should immediately see that most tyrannosaurs are actually (relatively)#
# small (0-1000 Kg). Now for our boxplot:#
boxplot(TyrannosaurBodyMasses)
plot(x = VolcanoData[, "Latitude"], y = VolcanoData[, "Elevation"])
VolcanoData[which(VolcanoData[, "Elevation"] < 0), ]
browseURL("https://www.r-graph-gallery.com/")
browseURL("https://www.google.co.uk/search?q=why+pie+charts+are+terrible")
getwd()
getwd()
jpeg("TyrannosaurBodyMassesHistogram.jpg")#
hist(TyrannosaurBodyMasses)#
dev.off()
browseURL("TyrannosaurBodyMassesHistogram.jpg")
pdf("TyrannosaurBodyMassesHistogram.pdf")#
hist(TyrannosaurBodyMasses)#
dev.off()
# Take a look at the PDF file:#
browseURL("TyrannosaurBodyMassesHistogram.pdf")
# Try zooming in as far as you can until the image pixelates. You should find#
# this never happens. Another advantage of PDFs as output is we can include#
# multiple plots in them. Let's try adding all three plots from above into a#
# single PDF:#
pdf("Practical_1_plots.pdf")#
hist(TyrannosaurBodyMasses)#
boxplot(TyrannosaurBodyMasses)#
plot(VolcanoData[, "Latitude"], VolcanoData[, "Elevation"])#
dev.off()
pdf("Practical_1_plots.pdf")#
hist(TyrannosaurBodyMasses, main = "Histogram of tyrannosaur body masses",#
  xlab = "Body Mass (Kg)", col = "black")#
boxplot(TyrannosaurBodyMasses, main = "Boxplot of tyrannosaur body masses",#
  ylab = "Body Mass (Kg)")#
TyrannosaurBodyMasses <- TyrannosaurBodyMasses[order(TyrannosaurBodyMasses)]#
barplot(TyrannosaurBodyMasses, horiz = TRUE,#
main = "Bar plot of tyrannosaur body masses by species", xlab = "Body Mass (Kg)",#
  names.arg = FALSE, space = 0, border = 0, xlim = c(0, 11000))#
text(x = TyrannosaurBodyMasses, y = c(1:length(TyrannosaurBodyMasses)) - 0.6,#
  labels = gsub("_", " ", names(TyrannosaurBodyMasses)), pos = 4,#
  vfont = c("sans serif", "bold italic"), col = "black")#
plot(x = VolcanoData[, "Latitude"], y = VolcanoData[, "Elevation"],#
  main = "Scatter plot of volcano latitude vs elevation",#
  xlab = "Latitude (degrees; negative = S, positive = N)",#
  ylab = "Elevation (m)", pch = 20, col = "blue")#
install.packages("maps", dependencies = TRUE)#
library(maps)#
map(border = NA, fill = TRUE, col = "grey", main = "Map of world volcanoes")#
points(x = VolcanoData[, "Longitude"], y = VolcanoData[, "Latitude"], pch = 20,#
  col = "red")#
dev.off()
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
test <- AmmonitePlotter()
test
# Plot spiral:#
plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
test <- AmmonitePlotter()#
#
# Simple plot of single ammonite:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/ammonitetest.pdf")#
#
# Plot spiral:#
plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")#
#
# Close plot:#
dev.off()#
#
# Print four ammonites as test that bearing choice works:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/fourammonitetest.pdf")#
a000 <- AmmonitePlotter(termination_bearing = 0)#
a090 <- AmmonitePlotter(termination_bearing = 90)#
a180 <- AmmonitePlotter(termination_bearing = 180)#
a270 <- AmmonitePlotter(termination_bearing = 270)#
plot(a000$spiral[, "x"], a000$spiral[, "y"], xlim = c(0, 4000), ylim = c(0, 4000), type = "n", xlab = "x", ylab = "y")#
points(a180$spiral[, "x"] + 1000, a180$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a180$wall_coordinates)) points(x = a180$wall_coordinates[i, c("x1", "x2")] + 1000, y = a180$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a270$spiral[, "x"] + 3000, a270$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a270$wall_coordinates)) points(x = a270$wall_coordinates[i, c("x1", "x2")] + 3000, y = a270$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a090$spiral[, "x"] + 1000, a090$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a090$wall_coordinates)) points(x = a090$wall_coordinates[i, c("x1", "x2")] + 1000, y = a090$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
points(a000$spiral[, "x"] + 3000, a000$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a000$wall_coordinates)) points(x = a000$wall_coordinates[i, c("x1", "x2")] + 3000, y = a000$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
dev.off()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
# Begin plotting of rulers:#
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Rulers.pdf", height = 8, width = 8)#
#
# Will need 3 of them (3 * 33, i.e., 99):#
for(k in 1:3) {#
  # Set margins of plot to zero:#
  par(mai = c(0, 0, 0, 0))#
  # Create empty plot of quadrat:#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  # Ruler plotting function:#
  Rulers <- function(originx, originy) {#
    # Draw main line of ruler:#
    lines(x = c(originx, originx + 300), y = c(originy, originy))#
    # Plot large ticks (every 100 mm):#
    for(i in seq(from = originx, to = originx + 300, length.out = 4)) lines(x = c(i, i), y = c(originy - 15, originy))#
    # Plot medium ticks (every 10 mm)#
    for(i in seq(from = originx, to = originx + 300, length.out = 31)) lines(x = c(i, i), y = c(originy - 12, originy))#
    # Plot small ticks (every 5mm):#
    for(i in seq(from = originx + 5, to = originx + 295, length.out = 30)) lines(x = c(i, i), y = c(originy - 9, originy))#
    # Plot 0 to 300 numbers every 100 mm:#
    text(x = originx, y = originy - 15, labels = c("0"), pos = 1)#
    text(x = originx + 100, y = originy - 15, labels = c("100"), pos = 1)#
    text(x = originx + 200, y = originy - 15, labels = c("200"), pos = 1)#
    text(x = originx + 300, y = originy - 15, labels = c("300"), pos = 1)#
  }#
  # For each row:#
  for(i in c(-50, 333, 750)) {#
    # For each column:#
    for(j in seq(from = 1000, to = 0, length.out = 11)) Rulers(i, j)#
  }#
}#
#
# Finish plotting to PDF:#
dev.off()#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/AllQuadrats.csv", row.names = FALSE)
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
test <- AmmonitePlotter()#
#
# Simple plot of single ammonite:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/ammonitetest.pdf")#
#
# Plot spiral:#
plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")#
#
# Close plot:#
dev.off()#
#
# Print four ammonites as test that bearing choice works:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/fourammonitetest.pdf")#
a000 <- AmmonitePlotter(termination_bearing = 0)#
a090 <- AmmonitePlotter(termination_bearing = 90)#
a180 <- AmmonitePlotter(termination_bearing = 180)#
a270 <- AmmonitePlotter(termination_bearing = 270)#
plot(a000$spiral[, "x"], a000$spiral[, "y"], xlim = c(0, 4000), ylim = c(0, 4000), type = "n", xlab = "x", ylab = "y")#
points(a180$spiral[, "x"] + 1000, a180$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a180$wall_coordinates)) points(x = a180$wall_coordinates[i, c("x1", "x2")] + 1000, y = a180$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a270$spiral[, "x"] + 3000, a270$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a270$wall_coordinates)) points(x = a270$wall_coordinates[i, c("x1", "x2")] + 3000, y = a270$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a090$spiral[, "x"] + 1000, a090$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a090$wall_coordinates)) points(x = a090$wall_coordinates[i, c("x1", "x2")] + 1000, y = a090$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
points(a000$spiral[, "x"] + 3000, a000$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a000$wall_coordinates)) points(x = a000$wall_coordinates[i, c("x1", "x2")] + 3000, y = a000$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
dev.off()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}
plot(type = "n")
plot(x = 1, y = 1, type = "n")
plot(x = 1, y = 1, type = "n", axes = FALSE)
plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
test <- AmmonitePlotter()#
#
# Simple plot of single ammonite:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/ammonitetest.pdf")#
#
# Plot spiral:#
plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")#
#
# Close plot:#
dev.off()#
#
# Print four ammonites as test that bearing choice works:#
pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/fourammonitetest.pdf")#
a000 <- AmmonitePlotter(termination_bearing = 0)#
a090 <- AmmonitePlotter(termination_bearing = 90)#
a180 <- AmmonitePlotter(termination_bearing = 180)#
a270 <- AmmonitePlotter(termination_bearing = 270)#
plot(a000$spiral[, "x"], a000$spiral[, "y"], xlim = c(0, 4000), ylim = c(0, 4000), type = "n", xlab = "x", ylab = "y")#
points(a180$spiral[, "x"] + 1000, a180$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a180$wall_coordinates)) points(x = a180$wall_coordinates[i, c("x1", "x2")] + 1000, y = a180$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a270$spiral[, "x"] + 3000, a270$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a270$wall_coordinates)) points(x = a270$wall_coordinates[i, c("x1", "x2")] + 3000, y = a270$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
points(a090$spiral[, "x"] + 1000, a090$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a090$wall_coordinates)) points(x = a090$wall_coordinates[i, c("x1", "x2")] + 1000, y = a090$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
points(a000$spiral[, "x"] + 3000, a000$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
for(i in 1:nrow(a000$wall_coordinates)) points(x = a000$wall_coordinates[i, c("x1", "x2")] + 3000, y = a000$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
dev.off()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Empty plot (second page for two-sided printing):#
        plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
# Begin plotting of rulers:#
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Rulers.pdf", height = 8, width = 8)#
#
# Will need 3 of them (3 * 33, i.e., 99):#
for(k in 1:3) {#
  # Set margins of plot to zero:#
  par(mai = c(0, 0, 0, 0))#
  # Create empty plot of quadrat:#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  # Ruler plotting function:#
  Rulers <- function(originx, originy) {#
    # Draw main line of ruler:#
    lines(x = c(originx, originx + 300), y = c(originy, originy))#
    # Plot large ticks (every 100 mm):#
    for(i in seq(from = originx, to = originx + 300, length.out = 4)) lines(x = c(i, i), y = c(originy - 15, originy))#
    # Plot medium ticks (every 10 mm)#
    for(i in seq(from = originx, to = originx + 300, length.out = 31)) lines(x = c(i, i), y = c(originy - 12, originy))#
    # Plot small ticks (every 5mm):#
    for(i in seq(from = originx + 5, to = originx + 295, length.out = 30)) lines(x = c(i, i), y = c(originy - 9, originy))#
    # Plot 0 to 300 numbers every 100 mm:#
    text(x = originx, y = originy - 15, labels = c("0"), pos = 1)#
    text(x = originx + 100, y = originy - 15, labels = c("100"), pos = 1)#
    text(x = originx + 200, y = originy - 15, labels = c("200"), pos = 1)#
    text(x = originx + 300, y = originy - 15, labels = c("300"), pos = 1)#
  }#
  # For each row:#
  for(i in c(-50, 333, 750)) {#
    # For each column:#
    for(j in seq(from = 1000, to = 0, length.out = 11)) Rulers(i, j)#
  }#
  # Empty plot (second page for two-sided printing):#
  plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
#
}#
#
# Finish plotting to PDF:#
dev.off()
# Begin plotting of rulers:#
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Rulers.pdf", height = 8, width = 8)#
#
# Will need 3 of them (3 * 33, i.e., 99):#
for(k in 1:3) {#
  # Set margins of plot to zero:#
  par(mai = c(0, 0, 0, 0))#
  # Create empty plot of quadrat:#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  # Ruler plotting function:#
  Rulers <- function(originx, originy) {#
    # Draw main line of ruler:#
    lines(x = c(originx, originx + 300), y = c(originy, originy))#
    # Plot large ticks (every 100 mm):#
    for(i in seq(from = originx, to = originx + 300, length.out = 4)) lines(x = c(i, i), y = c(originy - 15, originy))#
    # Plot medium ticks (every 10 mm)#
    for(i in seq(from = originx, to = originx + 300, length.out = 31)) lines(x = c(i, i), y = c(originy - 12, originy))#
    # Plot small ticks (every 5mm):#
    for(i in seq(from = originx + 5, to = originx + 295, length.out = 30)) lines(x = c(i, i), y = c(originy - 9, originy))#
    # Plot 0 to 300 numbers every 100 mm:#
    text(x = originx, y = originy - 15, labels = c("0"), pos = 1)#
    text(x = originx + 100, y = originy - 15, labels = c("100"), pos = 1)#
    text(x = originx + 200, y = originy - 15, labels = c("200"), pos = 1)#
    text(x = originx + 300, y = originy - 15, labels = c("300"), pos = 1)#
  }#
  # For each row:#
  for(i in c(-50, 333, 750)) {#
    # For each column:#
    for(j in seq(from = 1000, to = 0, length.out = 11)) Rulers(i, j)#
  }#
  # Empty plot (second page for two-sided printing):#
  plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
}#
#
# Finish plotting to PDF:#
dev.off()
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Protractor.pdf", height = 7, width = 7)#
#
par(mfrow = c(3, 3), mar = c(0.1, 0.1, 0.1, 0.1))#
#
for(k in 1:9) {#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  origin <- 550#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  origin <- -50#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  # Empty plot (second page for two-sided printing):#
  plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
}#
#
dev.off()
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Protractor.pdf", height = 7, width = 7)#
#
par(mfrow = c(3, 3), mar = c(0.1, 0.1, 0.1, 0.1))#
#
for(k in 1:9) {#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  origin <- 550#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  origin <- -50#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  # Empty plot (second page for two-sided printing):#
  plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
}#
#
dev.off()
par(mfrow = c(3, 3), mar = c(0.1, 0.1, 0.1, 0.1))
k <- 1
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  origin <- 550#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }
for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }
origin <- -50#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }
for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }
pdf("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Protractor.pdf", height = 7, width = 7)#
#
par(mfrow = c(3, 3), mar = c(0.1, 0.1, 0.1, 0.1))#
#
for(k in 1:9) {#
  plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
  origin <- 550#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  origin <- -50#
  points(x = c(500 - abs(cos((0:90) * (pi / 180)) * 500), rev(500 + abs(cos((0:90) * (pi / 180)) * 500))), y = c(origin + abs(sin((0:90) * (pi / 180)) * 500), rev(origin + abs(sin((0:90) * (pi / 180)) * 500))), type = "l")#
  lines(x = c(500, 500), y = c(origin, origin + 500))#
  lines(x = c(0, 1000), y = c(origin, origin))#
  for(i in (1:8 * 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 475)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 440)#
    adjacent4 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 475)#
    opposite3 <- abs(sin(i * (pi / 180)) * 440)#
    opposite4 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500, 500 + adjacent4), y = c(origin, origin + opposite4))#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
    text(x = 500 - adjacent3, y = origin + opposite3, labels = i + 270)#
    text(x = 500 + adjacent3, y = origin + opposite3, labels = abs(90 - i))#
  }#
  for(i in seq(from = 5, to = 85, by = 10)) {#
    adjacent1 <- abs(cos(i * (pi / 180)) * 500)#
    adjacent2 <- abs(cos(i * (pi / 180)) * 490)#
    adjacent3 <- abs(cos(i * (pi / 180)) * 400)#
    opposite1 <- abs(sin(i * (pi / 180)) * 500)#
    opposite2 <- abs(sin(i * (pi / 180)) * 490)#
    opposite3 <- abs(sin(i * (pi / 180)) * 400)#
    lines(x = c(500, 500 - adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500, 500 + adjacent3), y = c(origin, origin + opposite3), lwd = 0.7)#
    lines(x = c(500 - adjacent2, 500 - adjacent1), y = c(origin + opposite2, origin + opposite1))#
    lines(x = c(500 + adjacent2, 500 + adjacent1), y = c(origin + opposite2, origin + opposite1))#
  }#
  # Empty plot (second page for two-sided printing):#
  #plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
}#
#
dev.off()
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
#test <- AmmonitePlotter()#
#
# Simple plot of single ammonite:#
#pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/ammonitetest.pdf")#
#
# Plot spiral:#
#plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
#for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")#
#
# Close plot:#
#dev.off()#
#
# Print four ammonites as test that bearing choice works:#
#pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/fourammonitetest.pdf")#
#a000 <- AmmonitePlotter(termination_bearing = 0)#
#a090 <- AmmonitePlotter(termination_bearing = 90)#
#a180 <- AmmonitePlotter(termination_bearing = 180)#
#a270 <- AmmonitePlotter(termination_bearing = 270)#
#plot(a000$spiral[, "x"], a000$spiral[, "y"], xlim = c(0, 4000), ylim = c(0, 4000), type = "n", xlab = "x", ylab = "y")#
#points(a180$spiral[, "x"] + 1000, a180$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a180$wall_coordinates)) points(x = a180$wall_coordinates[i, c("x1", "x2")] + 1000, y = a180$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
#points(a270$spiral[, "x"] + 3000, a270$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a270$wall_coordinates)) points(x = a270$wall_coordinates[i, c("x1", "x2")] + 3000, y = a270$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
#points(a090$spiral[, "x"] + 1000, a090$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a090$wall_coordinates)) points(x = a090$wall_coordinates[i, c("x1", "x2")] + 1000, y = a090$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
#points(a000$spiral[, "x"] + 3000, a000$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a000$wall_coordinates)) points(x = a000$wall_coordinates[i, c("x1", "x2")] + 3000, y = a000$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
#dev.off()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Empty plot (second page for two-sided printing):#
        plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/AllQuadrats.csv", row.names = FALSE)
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (as first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Get one ammonite:#
#test <- AmmonitePlotter()#
#
# Simple plot of single ammonite:#
#pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/ammonitetest.pdf")#
#
# Plot spiral:#
#plot(test$spiral[, "x"], test$spiral[, "y"], xlim = c(-1000, 1000), ylim = c(-1000, 1000), type = "l")#
#
# Plot chamber walls:#
#for(i in 1:nrow(test$wall_coordinates)) points(x = test$wall_coordinates[i, c("x1", "x2")], y = test$wall_coordinates[i, c("y1", "y2")], type = "l")#
#
# Close plot:#
#dev.off()#
#
# Print four ammonites as test that bearing choice works:#
#pdf("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/fourammonitetest.pdf")#
#a000 <- AmmonitePlotter(termination_bearing = 0)#
#a090 <- AmmonitePlotter(termination_bearing = 90)#
#a180 <- AmmonitePlotter(termination_bearing = 180)#
#a270 <- AmmonitePlotter(termination_bearing = 270)#
#plot(a000$spiral[, "x"], a000$spiral[, "y"], xlim = c(0, 4000), ylim = c(0, 4000), type = "n", xlab = "x", ylab = "y")#
#points(a180$spiral[, "x"] + 1000, a180$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a180$wall_coordinates)) points(x = a180$wall_coordinates[i, c("x1", "x2")] + 1000, y = a180$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
#points(a270$spiral[, "x"] + 3000, a270$spiral[, "y"] + 3000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a270$wall_coordinates)) points(x = a270$wall_coordinates[i, c("x1", "x2")] + 3000, y = a270$wall_coordinates[i, c("y1", "y2")] + 3000, type = "l")#
#points(a090$spiral[, "x"] + 1000, a090$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a090$wall_coordinates)) points(x = a090$wall_coordinates[i, c("x1", "x2")] + 1000, y = a090$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
#points(a000$spiral[, "x"] + 3000, a000$spiral[, "y"] + 1000, xlim = c(0, 4000), ylim = c(0, 4000), type = "l")#
#for(i in 1:nrow(a000$wall_coordinates)) points(x = a000$wall_coordinates[i, c("x1", "x2")] + 3000, y = a000$wall_coordinates[i, c("y1", "y2")] + 1000, type = "l")#
#dev.off()#
#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Empty plot (second page for two-sided printing):#
        plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/AllQuadrats.csv", row.names = FALSE)
runif(N_ammonites, min = 0, max = 359)
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
      # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
      #while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
warnings()
AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])
r_max = 1000
N_points = 10000
seq(from = 0, to = r_max, length.out = N_points)
seq(from = 0, to = r_max, length.out = N_points) / a
seq(from = 0, to = r_max, length.out = N_points) / 0.1
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
      # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
      #while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
# For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])}
N_ammonites
origins
N_chambers[i]
aperture_bearings[i]
ammonite_sizes[i]
ammonite_sizes
sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))
order(origins[, 2], decreasing = TRUE)
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))#
cat(ammonite_sizes, "\n")}
}
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
dev.off()
sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))
sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))
sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40))
hist(sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40)))
for(i in 1:100) dev.off()
hist(sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 40)))
sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
      # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
      #while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
      # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
      #while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}
AllQuadrats
AllQuadrats[1:2, ]
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
  colnames(AllQuadrats)[1] <- "Quadrat"#
}
colnames(AllQuadrats)
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
  #colnames(AllQuadrats)[1] <- "Quadrat"#
}
colnames(AllQuadrats)[1]
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
  colnames(AllQuadrats)[1] <- "Quadrat"#
}
colnames(AllQuadrats)[1] <- "Quadrat"
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
colnames(AllQuadrats)[1] <- "Quadrat"
AllQuadrats[1:2, ]
AllQuadrats[, "Diameter_mm"]
hist(AllQuadrats[, "Diameter_mm"])
plot(AllQuadrats[, "N_chambers"], AllQuadrats[, "Diameter_mm"])
ammonite_i
AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = 100)
x <- AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = 100)
x
x$spiral
names(x)
x$wall_coordinates
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
ammonite_sizes
?text
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 1050, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 1000, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 900, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 100, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 1000, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 1050, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 900, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
?text
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n", vfont = c("Courier", "Regular"))
?vfont
?text
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = -20, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n", family = "mono")
plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = 0, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n", family = "mono")
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = 0, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n", family = "mono")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}
AmmonitePlotter(r_max=100)$spiral[, 2]
range(AmmonitePlotter(r_max=100)$spiral[, 2])
fonts
fonts <- list(#
  sans = "Helvetica",#
  mono = "Consolas",#
  `Times New Roman` = "DejaVu Serif"#
)#
#
ss <- svgstring(system_fonts = fonts)#
plot(1:10)#
text(0.8, 0.8, "Some text", family = "mono")#
text(0.2, 0.2, "Other text", family = "Times New Roman")
x <- AmmonitePlotter(r_max=100)
x$spiral[x$wall_begins, ]
x$spiral[x$wall_begins, 1] ^ 2
(x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2)
sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))
plot(sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2)))
x <- AmmonitePlotter(r_max=100, N_chambers=20)
plot(sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2)))
sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))
Radii <- sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))
Radii
Radii <- sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))#
#
for(i in 1:length(Radii)) diff(range(AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = Radii[i])$spiral[, "y"]))
Radii <- sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))#
Diameters <- vector(mode = "numeric")#
for(i in 1:length(Radii)) Diameters[i] <- diff(range(AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = Radii[i])$spiral[, "y"]))
Radii
Diameters
plot(Radii, Diameters)
Diameter/Radii
Diameters/Radii
Radii/Diameters
Diameters * 0.6130215
Radii
lm(Diameter ~ Radii)
lm(Diameters ~ Radii)
lm(Diameters ~ log(Radii))
plot(lm(Diameters ~ log(Radii)))
plot(lm(Diameters ~ log(Radii)))
plot(lm(Diameters ~ Radii^2 + Radii))
Diameters
(1 / 0.15) * log(Radii / 0.1)
Radii <- sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))#
Diameters <- vector(mode = "numeric")#
for(i in 1:length(Radii)) Diameters[i] <- diff(range(AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = Radii[i])$spiral[, "y"]))#
#
Theta <- (1 / 0.15) * log(Radii / 0.1)#
Radii[2:length(r)] * cos(theta[2:length(Theta)])#
Radii[2:length(r)] * sin(theta[2:length(Theta)])
Theta <- (1 / 0.15) * log(Radii / 0.1)#
Radii[2:length(Radii)] * cos(theta[2:length(Theta)])#
Radii[2:length(Radii)] * sin(theta[2:length(Theta)])
Theta <- (1 / 0.15) * log(Radii / 0.1)#
Radii[2:length(Radii)] * cos(Theta[2:length(Theta)])#
Radii[2:length(Radii)] * sin(Theta[2:length(Theta)])
Theta <- (1 / 0.15) * log(Radii / 0.1)#
sqrt((Radii[2:length(Radii)] * cos(Theta[2:length(Theta)]) ^ 2) + (Radii[2:length(Radii)] * sin(Theta[2:length(Theta)]) ^ 2))
Diameter
Diameters
# TO DO:#
# - Measure size at each chamber wall!#
#
# a = first spiral constant#
# b = second spiral constant#
# N_points = number of points to define the spiral#
# r_max = The maximum r value (polar coordinate) used to draw the spiral#
# N_chambers = the number of chambers to draw#
# chamber_exponent = the exponent value to use in spacing the chamber walls#
# chamber_wall_proportion = the proportion (distance to center) to use when drawing the chamber wall (found by guessing although an approximation seems possible!)#
# termination_bearing = bearing of aperture from origin in degrees (0/360 being "North", i.e., the top)#
#
AmmonitePlotter <- function(a = 0.1, b = 0.15, N_points = 10000, r_max = 1000, N_chambers = 30, chamber_exponent = 1.14, chamber_wall_proportion = 0.39, termination_bearing = 180) {#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Create spiral matrix from cartesian coordinates:#
    #spiral <- cbind(x, y)#
    # Add column names to spiral values:#
    #colnames(spiral) <- c("x", "y")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (or first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y#
    # Rotate x and y of chamber walls but do not override yet (would create error as need original coordinates for y rotation after x rotation:#
    new_wall_x <- (chamberwalls[, c("x1", "x2")] * cos(rotateradians)) - (chamberwalls[, c("y1", "y2")] * sin(rotateradians))#
    new_wall_y <- (chamberwalls[, c("x1", "x2")] * sin(rotateradians)) + (chamberwalls[, c("y1", "y2")] * cos(rotateradians))#
#
    # Update chambr walls with new (rotated) x and y:#
    chamberwalls[, c("x1", "x2")] <- new_wall_x#
    chamberwalls[, c("y1", "y2")] <- new_wall_y#
    # Compile output:#
    output <- list(cbind(x, y), chamberwall, chamberwalls)#
    # Add anems to output:#
    names(output) <- c("spiral", "wall_begins", "wall_coordinates")#
    # Return output:#
    return(output)#
}#
#
# Short function to convert maximum diameter into a radius:#
AmmoniteMaxDiameterToMaxRadius <- function(x) x * 0.6130215#
Radii <- sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))#
Diameters <- vector(mode = "numeric")#
for(i in 1:length(Radii)) Diameters[i] <- diff(range(AmmonitePlotter(N_chambers = 20, termination_bearing = 0, r_max = Radii[i])$spiral[, "y"]))#
#
Theta <- (1 / 0.15) * log(Radii / 0.1)#
sqrt((Radii[2:length(Radii)] * cos(Theta[2:length(Theta)]) ^ 2) + (Radii[2:length(Radii)] * sin(Theta[2:length(Theta)]) ^ 2))#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
    # For the Yth quadrat (1-10) column:#
    for(Y in 1:10) {#
        # Start writing to file:#
        pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
        # Set margins of plot to zero:#
        par(mai = c(0, 0, 0, 0))#
        # Set number of ammonites:#
        N_ammonites <- 20#
        # Set mean ammonite size (in mm):#
        mean_ammonite_size <- 100#
        # Draw random aperture bearings of ammonites (to be used later for current direction):#
        aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 13) %% 360#
        # Make sure bearings span 360/0 so that students can learn problem with non-circular stats:#
        while((any(aperture_bearings < 60) + any(aperture_bearings > 300)) < 2) aperture_bearings <- rnorm(N_ammonites, mean = 0, sd = 30) %% 360#
        # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
        N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Make sure there are at least five different chamber numbers in the sample:#
        while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 20, 30)))#
        # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
        ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 20))#
        # Create empty plot of quadrat:#
        plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
        # Plot smaller ten cm sub-quadrat lines:#
        for(i in seq(from = 100, to = 900, length.out = 9)) {#
            # Plot verticals:#
            lines(x = c(i, i), y = c(0, 1000), col = "grey")#
            # Plot horizontals:#
            lines(x = c(0, 1000), y = c(i, i), col = "grey")#
        }#
        # Draw out borders of quadrat:#
        lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
        # Draw starting origin at random:#
        origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        # For each subsequent ammonite:#
        for(i in 2:N_ammonites) {#
            # Draw new origin:#
            origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
            # Redraw origin if too close to other ammonites until safe separation found (will effect distances later):#
            while(any(dist(origins) < (1.75 * mean_ammonite_size))) origins[i, ] <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
        }#
        # For each ammonite:#
        for(i in 1:N_ammonites) {#
            # Get origin:#
            origin <- origins[i, ]#
            # Get x/y coordinates for ammonite:#
            ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
            # Plot ammonite spiral in quadrat:#
            points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
            # Plot ammonite chamber walls in quadrat:#
            for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
        }#
        # Add quadrat name to top left:#
        text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Lower bed)", sep = "")), pos = 4)#
        # Add compass point (N) at top left:#
        lines(x = c(-50, -50), y = c(850, 1000))#
        lines(x = c(-60, -40), y = c(925, 925))#
        polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
        text(x = -50, y = 1040, labels = c("N"), pos = 1)#
        # Add scale bar at bottom right:#
        polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
        text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
        # Add ammonite numbers (to match to data):#
        text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
        # Empty plot (second page for two-sided printing):#
        plot(x = 1, y = 1, type = "n", axes = FALSE, xlab = "", ylab = "")#
        # Close plot/stop plotting to PDF:#
        dev.off()#
        # Create sorted data (numbered as in plot from top to bottom):#
        ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
        N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
        aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
        origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
        # Convert ammonite size to measured value:#
        for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
        # Round all values to a realistic level of precision:#
        ammonite_sizes <- round(ammonite_sizes)#
        aperture_bearings <- round(aperture_bearings)#
        origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
        # Place data for quadrat into single matrix:#
        quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
        # Add column names to data:#
        colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
        # Write out as CSV:#
        write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
    }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/AllQuadrats.csv", row.names = FALSE)#
# For the Xth quadrat (A-J) row:#
for(X in LETTERS[1:10]) {#
  # For the Yth quadrat (1-10) column:#
  for(Y in 1:10) {#
    # Start writing to file:#
    pdf(paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/", X, Y, ".pdf", sep = ""), height = 8, width = 8)#
    # Set margins of plot to zero:#
    par(mai = c(0, 0, 0, 0))#
    # Set number of ammonites:#
    N_ammonites <- 20#
    # Set mean ammonite size (in mm):#
    mean_ammonite_size <- 80#
    # Draw random aperture bearings of ammonites (to be used later for current direction):#
    aperture_bearings <- runif(N_ammonites, min = 0, max = 359)#
    # Make random draw of ammonite chamber number (sorted so there will be a relationship with size for regression):#
    N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Make sure there are at least five different chamber numbers in the sample:#
    while(length(unique(N_chambers)) < 4) N_chambers <- sort(round(runif(N_ammonites, 10, 30)))#
    # Draw ammonite sizes (sorted so there will be a relationship with N chambers for regression):#
    ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Check for super small and negative ammonites and redraw if found:#
    while(min(ammonite_sizes) < 10) ammonite_sizes <- sort(rnorm(N_ammonites, mean = mean_ammonite_size, sd = 30))#
    # Create empty plot of quadrat:#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    # Plot smaller ten cm sub-quadrat lines:#
    for(i in seq(from = 100, to = 900, length.out = 9)) {#
      # Plot verticals:#
      lines(x = c(i, i), y = c(0, 1000), col = "grey")#
      # Plot horizontals:#
      lines(x = c(0, 1000), y = c(i, i), col = "grey")#
    }#
    # Draw out borders of quadrat:#
    lines(x = c(0, 0, 1000, 1000, 0), y = c(0, 1000, 1000, 0, 0), lty = 2)#
    # Draw starting origin at random:#
    origins <- cbind(runif(1, 25, 950), runif(1, 25, 950))#
    # For each subsequent ammonite:#
    for(i in 2:N_ammonites) {#
      # Draw new origin:#
      origins <- rbind(origins, cbind(runif(1, 25, 950), runif(1, 25, 950)))#
    }#
    # For each ammonite:#
    for(i in 1:N_ammonites) {#
      # Get origin:#
      origin <- origins[i, ]#
      # Get x/y coordinates for ammonite:#
      ammonite_i <- AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = aperture_bearings[i], r_max = ammonite_sizes[i])#
      # Plot ammonite spiral in quadrat:#
      points(ammonite_i$spiral[, "x"] + origin[1], ammonite_i$spiral[, "y"] + origin[2], xlim = c(0, 4000), ylim = c(0, 4000), type = "l", lwd = 0.7)#
      # Plot ammonite chamber walls in quadrat:#
      for(j in 1:nrow(ammonite_i$wall_coordinates)) points(x = ammonite_i$wall_coordinates[j, c("x1", "x2")] + origin[1], y = ammonite_i$wall_coordinates[j, c("y1", "y2")] + origin[2], type = "l", lwd = 0.7)#
    }#
    # Add quadrat name to top left:#
    text(x = -20, y = 1050, labels = c(paste("Quadrat ", X, Y, "\n(Upper bed)", sep = "")), pos = 4)#
    # Add compass point (N) at top left:#
    lines(x = c(-50, -50), y = c(850, 1000))#
    lines(x = c(-60, -40), y = c(925, 925))#
    polygon(x = c(-60, -50, -40, -60), y = c(960, 1000, 960, 960), col = "black")#
    text(x = -50, y = 1040, labels = c("N"), pos = 1)#
    # Add scale bar at bottom right:#
    polygon(x = c(800, 800, 1000, 1000, 800), y = c(-60, -70, -70, -60, -60), col = "black")#
    text(x = 1020, y = -40, labels = c("20 cm"), pos = 2)#
    # Add ammonite numbers (to match to data):#
    text(x = origins[order(origins[, 2], decreasing = TRUE), 1], y = origins[order(origins[, 2], decreasing = TRUE), 2], labels = as.character(1:20), cex = 3, col = rgb(1, 0, 0, 0.5))#
    # Empty plot (second page for two-sided printing):#
    plot(x = 0, y = 0, xlim = c(-50, 1050), ylim = c(-50, 1050), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", bty = "n")#
    text(x = 0, y = 850, labels = "Some txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\nSome txt\n", family = "mono")#
    # Close plot/stop plotting to PDF:#
    dev.off()#
    # Create sorted data (numbered as in plot from top to bottom):#
    ammonite_sizes <- ammonite_sizes[order(origins[, 2], decreasing = TRUE)]#
    N_chambers <- N_chambers[order(origins[, 2], decreasing = TRUE)]#
    aperture_bearings <- aperture_bearings[order(origins[, 2], decreasing = TRUE)]#
    origins <- origins[order(origins[, 2], decreasing = TRUE), ]#
    # Convert ammonite size to measured value:#
    for(i in 1:20) ammonite_sizes[i] <- diff(range(AmmonitePlotter(N_chambers = N_chambers[i], termination_bearing = 0, r_max = ammonite_sizes[i])$spiral[, "y"]))#
    sqrt((x$spiral[x$wall_begins, 1] ^ 2) + (x$spiral[x$wall_begins, 2] ^ 2))#
    # Round all values to a realistic level of precision:#
    ammonite_sizes <- round(ammonite_sizes)#
    aperture_bearings <- round(aperture_bearings)#
    origins <- matrix(as.vector(round(origins)), ncol = 2, dimnames = list(1:20, c("x", "y")))#
    # Place data for quadrat into single matrix:#
    quadratdata <- cbind(1:20, origins, ammonite_sizes, N_chambers, aperture_bearings)#
    # Add column names to data:#
    colnames(quadratdata) <- c("Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")#
    # Write out as CSV:#
    write.csv(quadratdata, file = paste("/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/Quadrat_", X, Y, ".csv", sep = ""), row.names = FALSE)#
  }#
}#
#
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
colnames(AllQuadrats)[1] <- "Quadrat"#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Upper_Bed/AllQuadrats.csv", row.names = FALSE)
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[grep(".csv", list.files())]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))
AllQuadrats
CSVFiles
grep(".csv", list.files())
grep("Quadrat_", list.files())
intersect(grep(".csv", list.files()), grep("Quadrat_", list.files()))
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[intersect(grep(".csv", list.files()), grep("Quadrat_", list.files()))]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))
CSVFiles
setwd("~/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed")#
#
CSVFiles <- list.files()[intersect(grep(".csv", list.files()), grep("Quadrat_", list.files()))]#
#
AllQuadrats <- matrix(nrow = 0, ncol = 7, dimnames = list(c(), c("Quadrat_number", "Ammonite_number", "X_coordinate", "Y_coordinate", "Diameter_mm", "N_chambers", "Aperture_bearing_degrees")))#
#
for(i in CSVFiles) {#
  currentCSV <- read.csv(i)#
  currentCSV <- cbind(rep(strsplit(i, "_|\\.")[[1]][2], 20), currentCSV)#
  AllQuadrats <- rbind(AllQuadrats, currentCSV)#
}#
#
colnames(AllQuadrats)[1] <- "Quadrat"#
#
write.csv(AllQuadrats, file = "/Users/eargtl/Documents/Teaching/University of Leeds/SOEE1470/2018-2019/Ammonite_quadrats/Lower_Bed/AllQuadrats.csv", row.names = FALSE)
AmmonitePlotter(r_max = 100)
AmmonitePlotter(r_max = 100)$spiral[, 2]
a = 0.1#
  b = 0.15#
  r_max = 100#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)
y
a = 0.1#
  b = 0.15#
  r_max = 100#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)#
    # Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (or first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y
a = 0.1#
  b = 0.15#
  r_max = 100#
  N_points = 10000#
  N_chambers = 20#
  chamber_exponent = 1.14#
  chamber_wall_proportion = 0.39#
  termination_bearing = 0#
    # Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)
max(y)
# Get chamber wall start points:#
    chamberwall <- round((N_points * ((chamber_exponent ^ (1:N_chambers)) / (chamber_exponent ^ N_chambers))))#
    # Get coordinates for drawing chamber walls:#
    chamberwalls <- cbind(x[chamberwall], chamber_wall_proportion * x[chamberwall], y[chamberwall], chamber_wall_proportion * y[chamberwall])#
    # Add column names to chamber walls matrix:#
    colnames(chamberwalls) <- c("x1", "x2", "y1", "y2")#
    # Get bearing of aperture:#
    bearing <- ((-1 * (atan2(y[N_points], x[N_points]) * (180 / pi) - 180)) - 90) %% 360#
    # Get rotation radians required to shift aperture to chosen bearing:#
    rotateradians <- (bearing - termination_bearing) / (180 / pi)#
    # Rotate x and y to match new bearing but do not update x and y yet (or first step will mess up latter!)::#
    new_x <- (x * cos(rotateradians)) - (y * sin(rotateradians))#
    new_y <- (x * sin(rotateradians)) + (y * cos(rotateradians))#
    # Update x and y with newly rotated coordinates:#
    x <- new_x#
    y <- new_y
max(y)
max(x)
# Create r values (polar coordinates) from input:#
    r <- seq(from = 0, to = r_max, length.out = N_points)#
    # Logarithmic spiral equation to get theta (polar coordinates) for all values of r:#
    x <- y <- theta <- (1 / b) * log(r / a)#
    # Convert polar coordinates to cartesian values:#
    x <- r[2:length(r)] * cos(theta[2:length(theta)])#
    y <- r[2:length(r)] * sin(theta[2:length(theta)])#
    x <- c(0, x)#
    y <- c(0, y)
max(x)
max(y)
?Claddis
library(Claddis)
?Claddis
?Claddis
